package slp;
import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public String getText() {
		return lexer.getText();
	}
	
	public void syntax_error(Symbol s) {
		System.out.println("Line " + getLine()+": Syntax error; unexpected " + getText());
	}
:}

// This is just for debugging
scan with {:
	Symbol t = lexer.next_token();
	if (printTokens)
		System.out.println(getLine() + ":" + getText());
	return t; 
:};

/**********************/
/* TERMINALS (TOKENS) */
/**********************/
terminal SEMI;
terminal PLUS;
terminal MULTIPLY;
terminal DIVIDE;
terminal MINUS;
terminal LP;
terminal RP;
terminal ASSIGN;
terminal BOOLEAN;
terminal BREAK;
terminal CLASS;
terminal CONTINUE;
terminal COMMA;
terminal DOT;
terminal EQUAL;
terminal EXTENDS;
terminal ELSE;
terminal FALSE;
terminal TRUE;
terminal GT;
terminal GTE;
terminal IF;
terminal INT;
terminal LAND;
terminal LB;
terminal RCBR;
terminal LENGTH;
terminal NEW;
terminal LNEG;
terminal LOR;
terminal LT;
terminal LTE;
terminal MOD;
terminal NEQUAL;
terminal NULL;
terminal RB;
terminal LCBR;
terminal RETURN;
terminal STATIC;
terminal STRING;
terminal THIS;
terminal VOID;
terminal WHILE;

terminal Integer	INTEGER;
terminal String		ID;
terminal String		CLASS_ID;
terminal String		QUOTE;

/**********************/
/*    NONTERMINALS    */
/**********************/

non terminal Program program;
non terminal List<ICClass> class_list;
non terminal ICClass ic_class;
non terminal ClassParams class_param_lst;
non terminal ClassMethod method;
non terminal MethodFormal formal;
non terminal Type type, method_type;

non terminal List<ClassField> fields;
non terminal List<String> more_fields;
non terminal List<Formal> formal_lst, more_formals;


non terminal Expr expr;
non terminal Stmt stmt;
non terminal StmtList stmt_list;

non terminal FunctionCall FunctionCall;
non terminal ArgumentList ArgumentList;
non terminal ArgumentList NonEmptyArgumentList;
non terminal StaticFunctionCall StaticCall;
non terminal VirtualFunctionCall VirtualCall;
non terminal ValueLocation Location;
non terminal Literal Literal;

precedence left LOR;
precedence left LAND;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY;
precedence left GT, LT, GTE, LTE;

/**********************/
/*   THE IC GRAMMER   */
/**********************/

program ::= class_list:lst
	{:
		RESULT = new Program(lst);
	:}
;

class_list ::= class_list:lst ic_class:c
	{: 
		lst.add(c); 
		RESULT = lst; 
	:}
  	| ic_class:c
  	{: 
  		RESULT = new ArrayList<ICClass>();
  		RESULT.add(c)
  	 :}
 ;

ic_class ::= CLASS:class_key CLASS_ID:name EXTENDS CLASS_ID:extended_class_name LCBR class_param_lst:params RCBR
	{:
		RESULT = new ICClass(name.toString(), extended_class_name.toString(), params.fields, params.methods);
	:} 
	| CLASS:class_key CLASS_ID:name LCBR class_param_lst:params RCBR
	{: 
		RESULT = new ICClass(name.toString(), null, params.fields, params.methods);
	:}
;

class_param_lst ::= class_param_lst:params method:m
	{: 
		params.methods.add(m);
		RESULT = params; 
	:}
	| class_param_lst:params fields:f
	{: 
		params.fields.addAll(f);
		RESULT = params; 
	:}
	| /* no fiels, no methods */
	{: 
		RESULT = new ClassParams();
	 :}
;

fields ::=  type:t ID:field_name more_fields:field_names_lst
	{: 
		field_names_lst.add(0, field_name.toString());
		List<Field> fields_list = new ArrayList<Field>();
		for (int i = 0; i < field_names_lst.size(); i++)
			fields_list.add(new ClassField(0,field_names_lst.get(i))); 
		RESULT = fields_list; 
	:}
;

more_fields ::= COMMA ID:field_name more_fields:field_names_lst
			{: 
			 	field_names_lst.add(0, field_name.toString());
			 	RESULT = field_names_lst;
			 :}
			| SEMI
 			{:
 				RESULT = new ArrayList<String>();
 			:}
 ;
 
 method ::= STATIC method_type:t ID:method_name LP formal_lst:f_lst RP LB stmt_list:s_lst RB 
			{: 
				RESULT = new StaticMethod(t, method_name.toString(), f_lst, s_lst);
			:}
			| STATIC VOID:v ID:method_name LP formal_lst:f_lst RP LB stmt_list:s_lst RB 
			{:
				RESULT = new StaticMethod(new PrimitiveType(DataTypes.VOID), method_name.toString(), f_lst, s_lst);
			:}
			| method_type:t ID:method_name LP formal_lst:f_lst RP LB stmt_list:s_lst RB
			{: 
				RESULT = new VirtualMethod(t, method_name.toString(), f_lst, s_lst);
			:}
			| VOID:v ID:method_name LP formal_lst:f_lst RP LB stmt_list:s_lst RB
			{: 
				RESULT = new VirtualMethod(new PrimitiveType(DataTypes.VOID), method_name.toString(), f_lst, s_lst);
			:}
; 

formal_lst ::= formal:f more_formals:m_formals 
			{:
				m_formals.add(0, f);
				RESULT = m_formals;
			:} 
			| 
			{:
				RESULT = new ArrayList<Formal>();
			:}
;

more_formals ::= COMMA formal:f more_formals:m_formals
			{:
				m_formals.add(0, f);
				RESULT = m_formals;
			:} 
			| 
			{:
				RESULT = new ArrayList<Formal>();
			:}
;

formal ::= type:t ID:f_name
		{:
			RESULT = new MethodFormal(t, f_name.toString());
		:}
;

type ::= type:t LB RB
		{: 
			t.incrementDimension();
			RESULT = t;
		:}
		| INT:i
		{:
			RESULT = new PrimitiveType(DataTypes.INT);
		:}
		| BOOLEAN:b
		{:
			RESULT = new PrimitiveType(DataTypes.BOOLEAN);
		:}
		| QUOTE:s
		{:
			RESULT = new PrimitiveType(DataTypes.STRING);
		:}
		| CLASS_ID:c
		{:
			RESULT = new objectClassType(c.toString());
		:}
;

stmt_list ::= stmt:s
	{: RESULT = new StmtList(s); :}
	| stmt_list:sl stmt:s
	{: sl.addStmt(s); RESULT = sl; :}
;

stmt ::= VAR:v ASSIGN expr:e SEMI
	{: VarExpr ve = new VarExpr(v); RESULT = new AssignStmt(ve, e); :}
	| PRINT LP expr:e RP SEMI
	{: RESULT = new PrintStmt(e); :}
;

expr ::= expr:e1 PLUS:p expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.PLUS);
		   System.out.println("Reduced rule e1 + e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MINUS expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MINUS);
		   System.out.println("Reduced rule e1 - e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MULTIPLY expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MULT);
		   System.out.println("Reduced rule e1 * e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 DIVIDE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.DIV);
		   System.out.println("Reduced rule e1 / e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MOD expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MOD);
		   System.out.println("Reduced rule e1 % e2 for e1=" + e1 + " and e2="+e2);
		   :} 
		| expr:e1 LAND expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LAND);
		   System.out.println("Reduced rule e1 && e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LOR expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LOR);
		   System.out.println("Reduced rule e1 || e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LT);
		   System.out.println("Reduced rule e1 < e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GT);
		   System.out.println("Reduced rule e1 > e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LTE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LE);
		   System.out.println("Reduced rule e1 <= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GTE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GE);
		   System.out.println("Reduced rule e1 >= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 EQUAL expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.EQUAL);
		   System.out.println("Reduced rule e1 == e2 for e1=" + e1 + " and e2="+e2);
		   :}
		| expr:e1 NEQUAL expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.NEQUAL);
		   System.out.println("Reduced rule e1 != e2 for e1=" + e1 + " and e2="+e2);
		   :}
		| MINUS expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.MINUS); :} 
		| LNEG expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.LNEG); :}
		| LP expr:e RP
		{: RESULT = e; :}
		| INTEGER:n
		{: RESULT = new NumberExpr(n.intValue()); :}
		| READI LP RP
		{: RESULT = new ReadIExpr(); :}
		| VAR:v
		{: RESULT = new VarExpr(v); :}
		| THIS
		{: RESULT =  new This(); :}
		| NEW CLASS_ID:c1 LP RP
		{: RESULT = new newClass(c1.toString()); :}
		| NEW type:t1 LB expr:e1 RB
		{: RESULT = new newArray(t1,e1); :}
		| expr:e1 DOT LENGTH
		{: RESULT = new ExprLength(e1); :}
		| literal:l1
		{: RESULT = l1; :}
		| FunctionCall:c1
		{: RESULT = c1; :}
		| Location:l1
		{: RESULT = l1; :}
		
;

FunctionCall ::= 	StaticCall:c1
					{: RESULT = c1; :}
					| VirtualCall:c1
					{: RESULT = c1; :}
;

StaticCall ::= 	CLASS_ID:classid DOT ID:funcid LP ArgumentList:argslist RP
			 	{: RESULT = new StaticFunctionCall(classid.toString(), funcid.toString(), argslist); :}
;

VirtualCall ::= expr:e1 DOT ID:funcid LP ArgumentList:argslist RP
				{: RESULT = new VirtualFunctionCall(funcid, argslist, e1); :}
				| ID:funcid LP ArgumentList:argslist RP
				{: RESULT = new VirtualFunctionCall(funcid, argslist); :}
;

ArgumentList ::= 	NonEmptyArgumentList:l1
					{: RESULT = l1; :}
					| 
					{: RESULT = null; :}
;

NonEmptyArgumentList ::= expr:e1 COMMA ArgumentList:l1
				{: RESULT = new ArgumentList(e1, l1); :}
				| expr:e1
				{: RESULT = new ArgumentList(e1, null); :}
;

Location ::= 	ID:varID
				{: RESULT = new VarValueLocation(varID.toString()); :}
				| expr:e1 DOT ID:varID
				{: RESULT = new VarValueLocation(e1, varID.toString()); :}
				| expr:eId LB expr:eIndex RB
				{: RESULT = new ArrValueLocation(eId, eIndex); :}
;

Literal ::=		QUOTE:sLiteral
				{: RESULT = new StringLiteral(sLiteral); :}
				| INTEGER:iLiteral
				{: RESULT = new IntLiteral(iLiteral); :}
				| TRUE
				{: RESULT = new BoolLiteral(true); :}
				| FALSE
				{: RESULT = new BoolLiteral(false); :}
				| NULL
				{: RESULT = new NullLiteral(); :}
; 